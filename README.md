# Library API

***

- [Установка и запуск](#установка-и-запуск)
- [Выдача админки (Docker)](#выдача-админки-docker)
- [Эндпоинты](#эндпоинты)
- [Архитектура базы данных](#архитектура-базы-данных)

***

## Установка и запуск
1. Скопируйте себе репозиторий `git clone`
2. Создайте виртуальное окружение `python3 -m venv venv`
3. Активируйте его `source venv/bin/activate`
4. Создайте два файла в корне проекта: `.env` и `.end.db`, заполните следующим образом
и вставьте свои значения:

    ### .env
    ```
    DB_HOST=db
    DB_PORT=
    DB_USER=
    DB_PASSWORD=
    DB_NAME=
    ```
   
    ### .env.db
    ```
    POSTGRES_USER=
    POSTGRES_PASSWORD=
    POSTGRES_DB=
    ```
5. Вы можете либо запустить проект с помощью команды из консоли: `alembic upgrade head` и
`uvicorn main:app --reload`, либо с помощью Docker: `docker-compose build` и `docker-compose up`.

## Выдача админки (Docker)
У модели пользователя есть флаг `is_admin`, который позволяет делать ему все основные
запросы на создание, обновление и удаление объектов. Если вы не используете докер, то можете поменять
этот флаг у пользователя с помощью утилиты `pgAdmin 4`. Но чтобы сделать это во время
запущенного докер контейнера необходимо выполнить следующие команды:
1. Зарегистрировать пользователя по эндпоинту `/users/register`
2. Войти в контейнер и в бд `docker exec -it postgres_db psql -U <db_username> -d <db_name>`
3. Выполнить команду `UPDATE public.user SET is_admin = TRUE WHERE id = <user_id>;`

После этого у вас будет возможность выполнять все основные crud операции.

## Эндпоинты

Хоть каждый из них и передает суть своим названием, я коротко опишу их здесь:

**На `POST`, `PATCH` и `DELETE` запросы необходимо иметь права администратора (кроме регистрации, 
получения токена).
Для получения и возврата книги необходимо быть просто авторизованным.**

### /users

- `/register` [`POST`]: регистрация пользователя
- `/token` [`POST`]: получение jwt токена
- `/me` [`GET`]: информация о текущем пользователе (необходимо передавать токен с заголовком `Authorization: Bearer ...`)
- `/readers` [`GET`]: список читателей (т.к. модель у всех пользователей одна, то по сути читателем
является любой пользователь, у которого флаг `is_admin=False`)

### /authors

- `/` [`GET`, `POST`]: получить список всех авторов либо создать нового
  - `GET`: есть query параметры `skip` и `limit` для пагинации
- `/{author_id}` [`GET`, `PATCH`, `DELETE`]: получить, изменить или удалить выбранного автора

### /books

- `/` [`GET`, `POST`]: получить все книги или создать новую
    - `GET`: есть query параметры `skip` и `limit` для пагинации
- `/{book_id}` [`GET`, `POST`, `PATCH`]: получение, изменение или удаление выбранной книги
- `/{book_id}/take` [`POST`]: взять определенную книгу
    - необходимо отметить, что пользователь ***не может взять больше пяти книг одновременно***,
  также ***не может взять книгу, когда ее количество равно нулю, т.е. не осталось
  экземпляров*** и не ***может взять книгу, когда 
она уже у него есть*** (все ошибки обработаны и выдают соответствующие статус коды с комментариями)
    - количество экземпляров книги после взятия уменьшается на 1
- `/{book_id}/return` [`DELETE`]: вернуть определенную книгу
    - пользователь ***не может вернуть книгу, которую не брал***
    - количество экземпляров у книги после возврата увеличивается на 1

Для последних двух эндпоинтов добавлено логирование, все получения и возвраты книг фиксируются
в файл `library.log`

## Архитектура базы данных

### Таблица `user`

- `id: int`, `primary_key=True`
- `username: str`
- `is_admin: bool`
- `hashed_password: str`
- `books: relationship`
    - связь с таблицей `book`, в качестве промежуточной таблицы указана
  `user_book`

### Таблица `author`

- `id: int`, `primary_key=True`
- `name: str`
- `biography: str`
- `birthday: date`
- `books: relationship`
    - связь с таблицей `book`, в качестве промежуточной таблицы `author_book`

### Таблица `book`

- `id: int`, `primary_key=True`
- `title: str`
- `description: str`
- `publish_date: date` (добавляется автоматически)
- `genre: str`
- `available: int`
- `authors: relationship`
    - связь с таблицей `author`, в качестве промежуточной таблицы `author_book`
- `users: relationship`
    - связь с таблицей `user`, в качестве промежуточной таблицы `user_book`

### Таблица для Many-to-Many связи `author_book`

- `author_id: ForeignKey`, `primary_key=True`
- `book_id: ForeignKey`, `primary_key=True` 

### Таблица для Many-to-Many связи `user_book`

- `user_id: ForeignKey`, `primary_key=True`
- `book_id: ForeignKey`, `primary_key=True`
- `receive_date: date` (добавляется автоматически, дефолтное значение
сегодняшний день)
- `return_date: date` (предполагаемая дата возврата, добавляется неделя
от сегодняшнего дня)